<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gping&#39;s Blog</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-07T13:04:01.977Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Gping</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>markdown语法总结</title>
    <link href="http://yoursite.com/2018/01/07/2017-11-07markdown%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/07/2017-11-07markdown语法总结/</id>
    <published>2018-01-07T12:58:57.000Z</published>
    <updated>2018-01-07T13:04:01.977Z</updated>
    
    <content type="html"><![CDATA[<p><strong>区块引用，’&gt;’的使用</strong><br>就是直接在区块前面加上’&gt;’<br>代码应用示例</p><blockquote><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><p><strong>有序列表</strong></p><ol><li>这是第一</li><li>这是第四?（其实变成了第二，但是文字前面需要空格哦~）</li></ol><p>注意：如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 </p><p> 标签包起来</p><p><strong>代码区块</strong><br>可以隔一行，然后加四个空格（或者两个制表符，有的电脑一个制表符），下面就可以形成代码块了</p><p>这是一个普通的块</p><pre><code>这是一个代码块</code></pre><p><strong>分割线</strong><br>三个以上的星号、减号、底线</p><hr><hr><hr><p><strong>强调</strong><br>Markdown使用*和_作为强调字词的符号<br>一个的时候相当于 <em><br>两个的时候相当于strong</em></p><p><em>这是被强调的内容</em></p><p><strong>这是strong的内容</strong></p><p><strong>代码</strong><br>一小段代码,直接使用’`’</p><p><code>hello world</code></p><p><strong>图片</strong><br><img src="http://upload-images.jianshu.io/upload_images/1784460-8423523b2ee90056?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;区块引用，’&amp;gt;’的使用&lt;/strong&gt;&lt;br&gt;就是直接在区块前面加上’&amp;gt;’&lt;br&gt;代码应用示例&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;return shell_exec(&amp;quot;echo $input | $markdow
      
    
    </summary>
    
      <category term="实习" scheme="http://yoursite.com/categories/%E5%AE%9E%E4%B9%A0/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>前端代码规范</title>
    <link href="http://yoursite.com/2018/01/07/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/01/07/前端代码规范/</id>
    <published>2018-01-07T12:56:26.000Z</published>
    <updated>2018-01-07T13:03:18.712Z</updated>
    
    <content type="html"><![CDATA[<p>2017.11.6<br><strong>html开发代码规范部分整理</strong><br><img src="http://upload-images.jianshu.io/upload_images/1784460-30e0c365bddfa528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性顺序"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-3d456e45c4f340e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="label相关"></p><ul><li>相关属性声明应当归为一组，并要按照一定的顺序排列：<br><img src="http://upload-images.jianshu.io/upload_images/1784460-85bfdd0ca591ee71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性顺序"></li></ul><p><strong>CSS开发部分规范</strong><br>基于最近的父class或者基本（base）class作为新的class的前缀</p><p>less的使用规范（由于之前对less的了解还是有限的，所以这里可以先放放）</p><p><strong>JavaScript开发规范</strong>  </p><ul><li>常量命名形式：大写字符，并用下划线分隔</li><li>eslint使用的是Standard配置方案的话，句末的分号需要省略</li><li>不要在一个快内声明一个函数</li><li><p>操作DOM——使用原声的JavaScript</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/1784460-9a1e807e89c2c2c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包的缺点"></p></li><li><p>循环的话，尽量少使用for-in循环，使用常规的for循环或者数组的forEach</p></li><li><p>永远不要使用Array作为map/hash/associative数组，请用Oject来代替</p></li><li><p>文件或者类中有私有属性，变量和方法名应该以下划线“_”开头</p></li><li><p>字符串使用单引号而不是双引号</p></li><li><p>jsDoc</p></li></ul><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000" target="_blank" rel="noopener">git的安装的话，参考了廖雪峰的教程</a></p><p>node.js的安装，宿舍的网络比较差，所以打算去公司再安装</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017.11.6&lt;br&gt;&lt;strong&gt;html开发代码规范部分整理&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1784460-30e0c365bddfa528.png?imag
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="实习" scheme="http://yoursite.com/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>node学习之node基础</title>
    <link href="http://yoursite.com/2018/01/07/node%E5%AD%A6%E4%B9%A0%E4%B9%8Bnode%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/07/node学习之node基础/</id>
    <published>2018-01-07T12:52:22.000Z</published>
    <updated>2018-01-07T12:56:07.580Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在学习node，以下的笔记主要是自己看<strong>《Node.js开发指南》</strong>的笔记，下面的内容主要是1到4章的</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-137b3807f534ccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Node.js开发指南"></p><a id="more"></a><ul><li><p><strong>单线程</strong>、<strong>异步式I/O</strong>、<strong>事件驱动式</strong>的程序设计模型</p></li><li><p>Node.Js是可以让JavaScript运行在服务器端的开发平台</p></li><li><p>Node.js内建了一个HTTP服务器支持，也就是你可以轻而易举地实现一个网站和服务器的组合</p></li><li><p>Node.js还可以<strong>部署到非网络应用的环境下</strong>，比如一个命令行工具<br>Node.js可以调用C/C++的代码</p></li><li><p>Node.js在执行的过程中会维护一个<strong>事件队列</strong>，程序在执行时进入事件循环等待下一个事件到来，每个异步式I/O请求完成后会被推送到事件队列中，等待程序进程进行处理</p></li><li><p>内存上下文切换？？</p></li><li><strong>回调函数</strong>很重要</li><li><p><strong>Node.js的异步机制是基于事件的</strong>，所有的<strong>I/O、网络通信、数据库查询</strong>都以<strong>非阻塞的方式</strong>请求，返回的结果由<strong>事件循环处理</strong></p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/1784460-70472a3447e87bb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="异步机制"></p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/1784460-c3cb61efdd04649f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件循环"></p></li></ul><p>第三章 <strong>Node.js的快速入门</strong></p><ul><li><p>node script.js  其中script.js 就是脚本的文件名</p></li><li><p><code>node -e &quot;console.log(&#39;Hello&#39;)&quot;</code></p></li><li>Node的REPL模式,REPL<code>（Read-eval-print loop）</code>，即输入—求值—输出循环</li><li>两次Ctrl+c退出该模式</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-4218f620d019eb4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="node和php"></p><ul><li><p>使用<strong>supervisor</strong>可以实现“热加载<br><code>supervisor 文件名</code></p></li><li><p>当线程遇到I/O操作时候，不会以阻塞的方式等待I/O操作的完成或者数据的返回，而是将I/O请求发送给操作系统，<strong>继续执行下一条语句</strong>。当操作系统完成I/O操作时候，以<strong>事件的形式通知</strong>I/O操作的线程，线程会在<strong>待定的时间</strong>处理这个事件</p></li><li><p><strong>单线程、非阻塞</strong><br>I/O部分和计算部分。通常<strong>I/O部分</strong>占用的时间比<strong>计算的部分</strong>多得多</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-a83060ec2a0a9e80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多线程同步式"></p><ul><li><strong>异步式I/O</strong>比<strong>传统的多线程阻塞式I/O</strong>少了多线程的开销</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-cd43a641a031294a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="比较"></p><ul><li><p><strong>EventEmitter</strong></p></li><li><p><strong>require不会重复</strong>加载模块</p></li><li><p><strong>覆盖exports</strong><br>exports<br>使用<code>module.exports = Hello</code> 代替<code>exports.Hello = Hello</code></p></li><li><p>CommonJs规范应该具备以下特征：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-6b0a018efd43cb30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CommonJs"></p><ul><li><p>npm是node官方提供的包管理工具</p></li><li><p>获取一个包<br><code>npm [install/i]  [package_name]</code><br>本地模式和全局模式<br><code>npm [install/i]  -g [package_name]</code></p></li><li><p><strong>本地模式</strong>不会注册<strong>PATH环境变量</strong>，仅仅是把包安装到node_modules子目录下，其中的bin目录没有包含在PATH环境变量中，不能在命令行中调用</p></li><li><p>使用<strong>全局模式</strong>安装的包并不能直接在 JavaScript 文件中用<strong>require</strong>获得，因为 <strong>require</strong> 不会搜索 <strong>/usr/local/lib/node_modules/</strong>。</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-1be478106d44d8f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地模式与全局模式"></p><ul><li><p><code>npm link</code> 不支持Windows</p></li><li><p>通过使用<code>npm init</code>可以根据交互式问答产生一个符合标准的package.json</p></li><li><p><code>npm pubilsh</code>发布包  package.json中修改version字段，重新使用<code>npm publish</code>重新发布</p></li><li><p>node中的全局对象是<strong>global</strong>，所有的全局变量（除了global本身以外）都是<strong>global对象的属性</strong>    </p></li><li><p><strong>process就是一个全局变量</strong>，即global对象的属性。它用于描述当前<strong>node进程状态</strong>的对象，提供一个与操作系统的<strong>简单接口</strong></p></li><li><p><code>process.nextTick(callback)</code>的功能是为<strong>事件循环</strong>设置一项任务，Node.js会在下一次事件循环响应时候调用callback</p></li><li><p><strong>常用工具util</strong>是node的核心模块，提供<strong>常用函数的集合</strong>，用于弥补核心JavaScript的功能过于精简的不足</p></li><li><p><code>util.inherit(constructor,superConstructor)</code>是一个实现对象间原型继承的函数<br><code>util.inspect(object,[showHidden],[depth],[])</code>是将任意对象转换成字符串的方法，通常用于调试或者错误输出</p></li><li><p>对于每个时间，<strong>EventEmitter</strong>支持若干个事件监听器</p></li><li><p>Node标准库提供了<strong>http模块</strong>，其中封装了高效的<strong>HTTP服务器</strong>和一个简易的<strong>HTTP客户端</strong></p></li><li><p><strong>http.Server</strong>是HTTP模块中的<strong>HTTP服务器对象</strong>，用Node.js做的所有<strong>基于HTTP协议的系统</strong>，如网站、社交应用甚至代理服务器，都是基于http.Server实现的</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-e013ea6d8fefb62d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经典实例"></p><ul><li><p><strong>http.Server的事件</strong><br>对它的事件编写响应函数即可实现http服务器的所有功能<br><strong>request</strong><br><strong>connection</strong><br><strong>close</strong></p></li><li><p><code>http.createServer([requestListener])</code><br>功能是创建一个HTTP服务器并将requestListener作为request事件的监听函数</p></li><li><p><code>http.ServerRequest</code>是HTTP请求的信息<br>一般由http.Server的request事件发送的，作为第一个参数进行传递</p></li></ul><p>以下3个事件用于控制请求体传输<br><code>data</code><br><code>end</code><br><code>close</code></p><ul><li><code>http.ServerResponse</code>是返回给客户端的信息，决定了用户最后能够看到的内容。也是有<code>http.Server</code>的<strong>request事件</strong>发送的，作为第二个参数进行传递</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-51c4f86b62f76eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="重要成员函数"></p><ul><li>http模块提供两个函数<strong>http.request</strong>和<strong>http.get</strong>，功能是作为客户端向http服务器发起请求</li></ul><p><code>http.request(options,callback)</code>发起http请求。option是类似关联数组的对象，表示请求的参数，callback是请求的回调函数</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-215dcf619713a4ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-db116f0baa05f870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果"></p><ul><li><code>http.ClientRequest</code>是由<strong>http.request</strong>或者<strong>http.get</strong>返回的对象，表示一个已经产生而且正在进行的http请求</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在学习node，以下的笔记主要是自己看&lt;strong&gt;《Node.js开发指南》&lt;/strong&gt;的笔记，下面的内容主要是1到4章的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1784460-137b3807f534ccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Node.js开发指南&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>node学习之认识node</title>
    <link href="http://yoursite.com/2018/01/07/node%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AE%A4%E8%AF%86node/"/>
    <id>http://yoursite.com/2018/01/07/node学习之认识node/</id>
    <published>2018-01-07T12:50:20.000Z</published>
    <updated>2018-01-07T12:51:14.006Z</updated>
    
    <content type="html"><![CDATA[<p><strong>学习node的基础</strong></p><p>以下是看慕课网上<a href="http://www.imooc.com/learn/348" target="_blank" rel="noopener">进击Node.js基础（一）</a>的学习笔记<br><a id="more"></a></p><ul><li><p>解决什么样的问题？<br>整个web应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：<strong>服务器能够处理的并发连接的最大数量</strong></p></li><li><p>node的解决方法是：<strong>更改连接到服务器的方式</strong><br>node是一个服务器程序</p></li><li><p>node本身运行V8 JavaScript     <strong>V8 JavaScript引擎</strong>是Google用于其Google浏览器的底层JavaScript引擎</p></li><li><p>node实际上会使用Google编写的V8引擎，并将其重建成可在服务器端使用</p></li><li><p><strong>事件驱动编程：监听事件，编写一个回调函数</strong></p></li><li><p>c++语言编写<br>运行环境</p></li><li><p>自己特殊的<strong>全局变量</strong>：例如process</p></li><li><p><strong>模块与包模块工具</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//一个简单的例子</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function(req,res)&#123;</span><br><span class="line">    res.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text/plain&apos;&#125;);</span><br><span class="line">    res.end(&quot;hello \n&quot;);</span><br><span class="line">&#125;).listen(1337,&apos;127.0.0.1&apos;);</span><br><span class="line">console.log(&apos;Server running at http://127.0.0.1:1337/&apos;);</span><br></pre></td></tr></table></figure></li><li><p><strong>创建web服务器</strong></p></li><li><p>createServer(匿名回调函数).listen(端口号,IP)</p></li><li><p>Ctrl+C停止服务器</p></li><li><p>listen实现监听</p></li><li><p>JavaScript天生缺陷：缺少模块化机制<br>表现：JS中容易出现变量被覆盖，方法被替代的情况（即被污染）<br>传统解决方法：使用<strong>命名空间</strong>的方式，把变量和函数限制在某个特定的作用域中</p></li><li><p><strong>CommonJs规范</strong>：约定了JavaScript如何去组织，如何去编写，包括<strong>包、二进制、套接字、单元测试等等</strong>。首先把执行不同的任务代码块和代码文件看成一个独立的模块，每个模块都是一个单独的作用域，但不是孤立的，可能存在依赖关系。每个模块分成三个部分：<strong>定义、标志和引用</strong></p></li><li><p>nodeJS的模块管理机制<br><strong>npm</strong>是用来管理各种功能包的</p></li><li><p>模块的分类：<br><strong>核心模块、文件模块和第三方模块</strong></p></li><li><p>模块的引用：<br><strong>路径名</strong><br><strong>模块名</strong><br><strong>模块名引用最终也会被映射成路径。</strong></p></li><li><p>模块的流程：<br><strong>创建模块</strong><br><strong>导出模块</strong><br><strong>加载模块</strong><br><strong>使用模块</strong></p></li><li><p>使用<strong>require</strong>导入模块<br><strong>exports</strong>导出模块</p></li><li><p><code>module.exports</code>         <code>exports</code><br><code>module.exports</code>和<code>export</code>区别：<br><code>module.exports = add;</code>特别的对象类型;<code>exports.add = add;</code>传统的模块实例;（exports是辅助方法）<br><code>module.exports</code>最终返回给调用者；<br><code>exports</code>挂载属性和方法，然后把属性赋给<code>module.exports</code></p></li><li><p>forEach的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">students.forEach(function(item,index)&#123;</span><br><span class="line">    student.add(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://stackoverflow.com/questions/31534066/javascript-object-foreach-is-not-a-function" target="_blank" rel="noopener">记得只有真正的数组才能使用forEach</a><br><code>array = [].slice.call(el.children)</code></p><ul><li><p>url的parse方法将url解析成对象</p></li><li><p><code>url.parse(url字符串)</code></p></li><li><p><code>format    resolve</code><br>format和parse是相反的 </p></li><li><p>parse的第一个参数url字符串，第二个参数是布尔值  默认为false，如果是true的话，query将被解析成对象（false是字符串），第三个参数也会是布尔值，默认是false，设置为true的话，host的解析会有区别</p></li><li><p>序列化和反序列化</p></li><li><p><code>querystring.stringify</code>序列化<code>querystring.parse</code>反序列化</p></li><li><p><code>escape  unescape</code></p></li><li><p>escape进行转义，unescape进行反转义</p></li><li><p>使用技巧：GitHub中快捷键T可以更好搜索的文件路径</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);//简单爬虫的实现</span><br><span class="line">var url = &quot;http://www.imooc.com/video/7965&quot;</span><br><span class="line"></span><br><span class="line">http.get(url,function(res)&#123;</span><br><span class="line">    var html = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    res.on(&apos;data&apos;,function(data)&#123;</span><br><span class="line">        html += data;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    res.on(&apos;end&apos;,function()&#123;</span><br><span class="line">        console.log(html)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>node没有冒泡，捕获之类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;学习node的基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是看慕课网上&lt;a href=&quot;http://www.imooc.com/learn/348&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;进击Node.js基础（一）&lt;/a&gt;的学习笔记&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript（作用域与闭包）</title>
    <link href="http://yoursite.com/2018/01/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E9%97%AD%E5%8C%85%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/07/你不知道的JavaScript（作用域与闭包）/</id>
    <published>2018-01-07T12:48:26.000Z</published>
    <updated>2018-01-07T12:51:54.475Z</updated>
    
    <content type="html"><![CDATA[<p>看《你所不知道的JavaScript（上卷）》笔记<br><a id="more"></a></p><ul><li><p>RHS查询，LHS查询</p></li><li><p><img src="http://upload-images.jianshu.io/upload_images/1784460-5c95be005ea13eef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="变量的赋值过程"></p></li><li><p>RHS查询与简单地查找某个变量的值没有什么差别，但是LHS查询则是试图找到变量的容器本身，从而可以对他赋值</p></li><li><p>LHS——赋值的目标是谁？RHS——谁是赋值操作的源头？<br>如果查找的目的是对变量进行赋值，那么就会使用LHS 查询；如果目的是获取变量的值，就会使用RHS 查询。</p></li><li><p>作用域查找会在第一个匹配的标识符时停止</p></li><li><p>欺骗词法：</p></li></ul><p>1、使用eval，遮蔽了外部（全局）作用域中的同名变量</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-4817c770de591596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用eval"></p><p>在严格模式的程序中，eval(…)在运行时候有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p><p>2、with</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-2220834db993cd4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="with"></p><ul><li><p>作用域气泡的概念</p></li><li><p>从所写的代码中挑选出一段任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏起来”</p></li><li><p>隐藏内部实现</p></li><li><p>函数表达式和函数声明</p></li><li><p>推不推荐使用arguments.callee？</p></li><li><p>行内函数表达式非常强大而且有用</p></li><li><p>立即执行函数（IIFE Immediately Invoked Function Expression）   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function foo()&#123;...&#125;())  (function foo()&#123;...&#125;)()</span><br></pre></td></tr></table></figure></li></ul><p>IIFE 一个很普遍的进阶用法就是把它们当做函数调用并传参数过去</p><p>IIFE还有一种用途就是倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当做参数传递进去</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-f9d1be3693748d1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IIFE"></p><ul><li><p>try…catch…中的catch分句会创建一个块级作用域，其中声明的变量仅仅在catch的内部使用</p></li><li><p>引擎会在解释JavaScript代码之前首先对其进行编译，编译阶段中的一个部分工作就是找到所有的声明，并用合适的作用域将它们关联起来</p></li></ul><p>包含变量和函数在内的所有声明都会在任何代码被执行前首先被处理</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-bc851d0e36aab703.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="声明和赋值"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-b7a5fd0e46490859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="报错"></p><p>foo这个时候是undefined，但是对其进行函数调用的话会导致非法操作，因此抛出TypeError异常</p><ul><li><p>函数优先</p></li><li><p>当函数可以记住并访问当前所在的词法作用域时候，就产生了闭包，即使函数是在当前词法作用域之外执行的</p></li><li><p>原本应该在函数执行结束后进行垃圾回收，但是bar()所声明的位置决定了它拥有涵盖foo()内部作用域的闭包，使得该作用域一直存活着，从而提供bar()在之后任何时间进行引用</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-26a01df06bffc781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包"></p><ul><li>所有的函数共享一个i的引用。循环结构让我们误以为背后还有更加复杂的机制在起作用，但实际上是没有的。我们需要更多的闭包作用域，特别是循环的过程中每个迭代都需要有一个闭包作用域</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-c4f4e6b1ec8a7024.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="经典例子"></p><p>而通过IIFE可以声明并立即执行一个函数来创建作用域</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-a7d34fe303ba95dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-e68bd85944a32159.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p><p>注意两者的区别</p><ul><li>本质上这是将一个块转换成一个可以被关闭的作用域</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-7301a45bfee6b02a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-c39839dbf1cc41b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看《你所不知道的JavaScript（上卷）》笔记&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>在移动端测试前端页面（真机调试）</title>
    <link href="http://yoursite.com/2018/01/07/%E5%9C%A8%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8B%E8%AF%95%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%EF%BC%88%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95%EF%BC%89/"/>
    <id>http://yoursite.com/2018/01/07/在移动端测试前端页面（真机调试）/</id>
    <published>2018-01-07T12:25:45.000Z</published>
    <updated>2018-01-07T12:27:20.972Z</updated>
    
    <content type="html"><![CDATA[<p><strong>环境</strong><br>首先，要安装Git！下载node.js！安装淘宝镜像！</p><p><strong>过程</strong></p><ul><li>右键——Git bash<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">live-server</span><br></pre></td></tr></table></figure></li></ul><p>eg:这里就是8080</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-2b5a8bb6e8090280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获得端口号"></p><ul><li>window+X——选择命令行（管理员模式）</li><li>ipconfig</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/1784460-ece3c1648c29b3c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IPv4地址"></p><ul><li>利用手机连接电脑WiFi（处于同一个局域网下面）</li><li>在手机浏览器中输入IPv4地址：端口号。即可访问！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;&lt;br&gt;首先，要安装Git！下载node.js！安装淘宝镜像！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右键——Git bash&lt;figure class=&quot;highlight plain&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="前端技能" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="前端技能" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Font Awesome基础使用</title>
    <link href="http://yoursite.com/2018/01/07/Font-Awesome%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/07/Font-Awesome基础使用/</id>
    <published>2018-01-07T12:22:56.000Z</published>
    <updated>2018-01-07T12:24:42.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a><a href="http://fontawesome.dashgame.com/#basic" target="_blank" rel="noopener">下载</a></h2><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><ul><li>引入CSS文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;font-awesome-4.7.0/css/font-awesome.min.css&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本图标"><a href="#基本图标" class="headerlink" title="基本图标"></a>基本图标</h2><p>您可以将Font Awesome图标使用在几乎任何地方，只需要使用CSS前缀 fa ，再加上图标名称。 Font Awesome是为使用内联元素而设计的。我们通常更喜欢使用 i标签 ，因为它更简洁。 但实际上使用 <span> 才能更加语义化。</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-camera-retro&quot;&gt;&lt;/i&gt; fa-camera-retro</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1784460-2cd5dd9132ab25e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基本"></p><p>注：如果您修改了图标容器的字体大小，图标大小会随之改变。同样的变化也会发生在颜色、阴影等其它任何CSS支持的效果上。</p><h2 id="大图标"><a href="#大图标" class="headerlink" title="大图标"></a>大图标</h2><p>使用 fa-lg (33%递增)、fa-2x、 fa-3x、fa-4x，或者 fa-5x 类 来放大图标。</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-ae6570fb354fbf23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="大图标"></p><p>注：如果图标的底部和顶部被截断了，您需要增加行高来解决此问题。</p><h2 id="固定宽度"><a href="#固定宽度" class="headerlink" title="固定宽度"></a>固定宽度</h2><p>使用 fa-fw 可以将图标设置为一个固定宽度。主要用于不同宽度图标无法对齐的情况。 尤其在列表或导航时起到重要作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;list-group&quot;&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-home fa-fw&quot;&gt;&lt;/i&gt;  Home&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-book fa-fw&quot;&gt;&lt;/i&gt;  Library&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-pencil fa-fw&quot;&gt;&lt;/i&gt;  Applications&lt;/a&gt;</span><br><span class="line">  &lt;a class=&quot;list-group-item&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;fa fa-cog fa-fw&quot;&gt;&lt;/i&gt;  Settings&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1784460-52c90b4867160b67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="固定宽度"></p><h2 id="用于列表"><a href="#用于列表" class="headerlink" title="用于列表"></a>用于列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;fa-ul&quot;&gt;</span><br><span class="line">  &lt;li&gt;&lt;i class=&quot;fa-li fa fa-check-square&quot;&gt;&lt;/i&gt;List icons&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;i class=&quot;fa-li fa fa-check-square&quot;&gt;&lt;/i&gt;can be used&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;i class=&quot;fa-li fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;as bullets&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;i class=&quot;fa-li fa fa-square&quot;&gt;&lt;/i&gt;in lists&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1784460-d7a8ebfb3c36e1a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="列表"></p><h2 id="边框和对齐"><a href="#边框和对齐" class="headerlink" title="边框和对齐"></a>边框和对齐</h2><p>使用 fa-border 以及 pull-right 或 pull-left 可以轻易构造出引用的特殊效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-quote-left fa-3x pull-left fa-border&quot;&gt;&lt;/i&gt;</span><br><span class="line">...tomorrow we will run faster, stretch out our arms farther...</span><br><span class="line">And then one fine morning— So we beat on, boats against the</span><br><span class="line">current, borne back ceaselessly into the past.</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1784460-fb82a1452165a4b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="边框和对齐"></p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>使用 fa-spin 类来使任意图标旋转，现在您还可以使用 fa-pulse 来使其进行8方位旋转。尤其适合 fa-spinner、fa-refresh 和 fa-cog 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">                        &lt;i class=&quot;fa fa-circle-o-notch fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">                        &lt;i class=&quot;fa fa-refresh fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">                        &lt;i class=&quot;fa fa-cog fa-spin&quot;&gt;&lt;/i&gt;</span><br><span class="line">                        &lt;i class=&quot;fa fa-spinner fa-pulse&quot;&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p><p>注： CSS3动画不支持IE8-IE9。</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-0e5008df4921b80e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动画（截图）"></p><p>##旋转与翻转<br>使用 fa-rotate-<em> 和 fa-flip-</em> 类可以对图标进行任意旋转和翻转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;fa fa-shield&quot;&gt;&lt;/i&gt; normal&lt;br&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-shield fa-rotate-90&quot;&gt;&lt;/i&gt; fa-rotate-90&lt;br&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-shield fa-rotate-180&quot;&gt;&lt;/i&gt; fa-rotate-180&lt;br&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-shield fa-rotate-270&quot;&gt;&lt;/i&gt; fa-rotate-270&lt;br&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-shield fa-flip-horizontal&quot;&gt;&lt;/i&gt; fa-flip-horizontal&lt;br&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-shield fa-flip-vertical&quot;&gt;&lt;/i&gt; icon-flip-vertical</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-2c1be64a23b42dbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="旋转与翻转"></p><h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>如果想要将多个图标组合起来，使用 fa-stack类作为父容器， fa-stack-1x作为正常比例的图标， fa-stack-2x 作为大一些的图标。还可以使用 fa-inverse类来切换图标颜色。您可以在父容器中 通过添加 <a href="http://fontawesome.dashgame.com/#larger" target="_blank" rel="noopener">大图标</a> 类来控制整体大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class=&quot;fa-stack fa-lg&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-square-o fa-stack-2x&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-twitter fa-stack-1x&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">fa-twitter on fa-square-o&lt;br&gt;</span><br><span class="line">&lt;span class=&quot;fa-stack fa-lg&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-circle fa-stack-2x&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-flag fa-stack-1x fa-inverse&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">fa-flag on fa-circle&lt;br&gt;</span><br><span class="line">&lt;span class=&quot;fa-stack fa-lg&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-square fa-stack-2x&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-terminal fa-stack-1x fa-inverse&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">fa-terminal on fa-square&lt;br&gt;</span><br><span class="line">&lt;span class=&quot;fa-stack fa-lg&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-camera fa-stack-1x&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-ban fa-stack-2x text-danger&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">fa-ban on fa-camera</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-5afbd4ca011c03ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组合使用"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://fontawesome.dashgame.com/#basic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>网页自适应布局</title>
    <link href="http://yoursite.com/2018/01/07/%E7%BD%91%E9%A1%B5%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/01/07/网页自适应布局/</id>
    <published>2018-01-07T12:18:24.000Z</published>
    <updated>2018-01-07T12:21:34.965Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在网页代码头部，加入一行viewport元标签<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://developer.apple.com/library/ios/#DOCUMENTATION/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html" target="_blank" rel="noopener">viewport</a>是网页默认的宽度和高度，上面这行代码的意思是，网页宽度默认等于屏幕宽度（width=device-width），原始缩放比例（initial-scale=1）为1.0，即网页初始大小占屏幕面积的100%</p><ul><li>兼容性问题，几乎所有都支持，包括ie9,低于IE9的 ，需要用到下面的一段代码</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>不使用绝对宽度——css不能指定像素宽度，只能指定百分比,或者</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width:auto;</span><br></pre></td></tr></table></figure><ul><li>使用相对字体大小（em）,不能使用绝对字体大小（px）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　body &#123;</span><br><span class="line">　　　　font: normal 100% Helvetica, Arial, sans-serif;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>默认字体的100%，也就是16像素<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　h1 &#123;　　　　</span><br><span class="line">    font-size: <span class="number">1</span>.5em;　　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认像素的1.5倍</p><ul><li>使用流动布局<br>float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现</li></ul><p><strong>注意position的使用，有机会专题讨论</strong></p><ul><li>选择加载CSS</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> media=<span class="string">"screen and (max-device-width: 400px)"</span> href=<span class="string">"tinyScreen.css"</span> /&gt;</span><br></pre></td></tr></table></figure><p>上面的代码意思是，如果屏幕宽度小于400像素（max-device-width: 400px），就加载tinyScreen.css文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span></span><br><span class="line">　　　　media=<span class="string">"screen and (min-width: 400px) and (max-device-width: 600px)"</span></span><br><span class="line">　　　　href=<span class="string">"smallScreen.css"</span> /&gt;</span><br></pre></td></tr></table></figure><p>如果屏幕宽度在400像素到600像素之间，则加载smallScreen.css文件。</p><p>除了用html标签加载CSS文件，还可以在现有CSS文件中加载。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　@<span class="keyword">import</span> url("tinyScreen.css") screen and (max-device-width: 400px);</span><br></pre></td></tr></table></figure><ul><li>css的@media规则<br>同一个CSS文件中，也可以根据不同的屏幕分辨率，选择应用不同的CSS规则</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　@media screen and (<span class="built_in">max</span>-device-width: 400px) &#123;</span><br><span class="line">　　　　.column &#123;</span><br><span class="line">　　　　　　float: <span class="keyword">none</span>;</span><br><span class="line">　　　　　　width:auto;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　#sidebar &#123;</span><br><span class="line">　　　　　　display:<span class="keyword">none</span>;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>上面的代码意思是，如果屏幕宽度小于400像素，则column块取消浮动（float:none）、宽度自动调节（width:auto），sidebar块不显示（display:none）</p><ul><li>图片的自适应（fluid image）<br>除了布局和文本，”自适应网页设计”还必须实现图片的<a href="http://unstoppablerobotninja.com/entry/fluid-images" target="_blank" rel="noopener">自动缩放</a>。<br>这只要一行CSS代码：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img&#123;</span><br><span class="line">    <span class="built_in">max</span>-width:<span class="number">100</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这行代码对于大多数的嵌入网页的视频也有效<br>老版本的IE不支持max-width，所以只好写成：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　img &#123; width: <span class="number">100</span>%; &#125;</span><br></pre></td></tr></table></figure><p>此外，windows平台缩放图片时，可能出现图像失真现象。这时，可以尝试使用IE的<a href="http://css-tricks.com/ie-fix-bicubic-scaling-for-images/" target="_blank" rel="noopener">专有命令</a>：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　img &#123; -ms-interpolation-mode: bicubic; &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;在网页代码头部，加入一行viewport元标签&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>学校项目总结</title>
    <link href="http://yoursite.com/2018/01/07/%E5%AD%A6%E6%A0%A1%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/07/学校项目总结/</id>
    <published>2018-01-07T12:11:01.000Z</published>
    <updated>2018-01-07T12:37:41.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在学校的时候，有幸接到一个关于思政类型的项目（类似于一些新闻网站）。其实内容并不复杂，只是当时能力有限，现在回头总结一下当时的一些问题。</p><a id="more"></a><h2 id="制作甘特图"><a href="#制作甘特图" class="headerlink" title="制作甘特图"></a>制作甘特图</h2><p>在项目开始阶段，由于时间紧迫，制作甘特图安排任务</p><p><a href="http://jingyan.baidu.com/article/ceb9fb10d9cac48cad2ba02b.html" target="_blank" rel="noopener">使用Visio轻松绘制甘特图和制定项目计划</a></p><p><a href="https://www.baidu.com/link?url=Od07jAlqvJGxW6yDVrf9LwS-5N34VQ70t15Zk_PGF0qJZryW_g4dTI_PgHV74dff9qPmO0xRfYCoQBM89m3_z5ESKptwvLgrujVH2CgXlOG&amp;wd=&amp;eqid=be6f3b070002fcf200000006591689b2" target="_blank" rel="noopener">excel制作甘特图(excel2010)</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-596d092cd566eaab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用Excel制作的甘特图"></p><h2 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a>@font-face</h2><p><strong>浏览器支持情况</strong></p><ul><li>IE9只支持.eot类型的字体</li><li>Firefox，chrome，Safari，Opera支持.ttf  与.otf两种类型字体</li></ul><p>注意： Internet Explorer 8 及更早IE版本不支持@font-face 规则.</p><p><strong>属性定义及使用说明</strong><br>@font-face规则，网页设计师再也不必使用的”web-safe”的字体之一。</p><ul><li><p>字体的名称，font - face规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font-family: myFirstFont;</span><br></pre></td></tr></table></figure></li><li><p>字体文件包含在您的服务器上的某个地方，参考CSS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src: url(&apos;Sansation_Light.ttf&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>如果字体文件是在不同的位置，请使用完整的URL：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src: url(&apos;http://www.w3cschool.css/css3/Sansation_Light.ttf&apos;)</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-bd67fb298f561c1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-858815370f0c5306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="去除inline-block元素间间距的N种方法"><a href="#去除inline-block元素间间距的N种方法" class="headerlink" title="去除inline-block元素间间距的N种方法"></a>去除inline-block元素间间距的N种方法</h2><p><a href="http://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="noopener">转载</a></p><h2 id="图标无法显示"><a href="#图标无法显示" class="headerlink" title="图标无法显示"></a>图标无法显示</h2><p><a href="http://www.jb51.net/article/92013.htm" target="_blank" rel="noopener">BootStrap glyphicon图标无法显示的解决方法</a></p><ul><li>需要将fonts文件放在目录下</li></ul><h2 id="vertical-align"><a href="#vertical-align" class="headerlink" title="vertical-align"></a>vertical-align</h2><p><a href="http://www.111cn.net/cssdiv/css/42277.htm" target="_blank" rel="noopener">css vertical-align:middle来实现垂直居中</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>在项目的过程中有文字溢出，后来听同学说CSS3总有个属性可以解决，就是text-overflow。</p><p>关于字母之间的距离word-spacing属性</p><p><a href="http://www.jb51.net/web/412110.html" target="_blank" rel="noopener">CSS实现单行、多行文本溢出显示省略号的实现方法</a></p><p>要学会使用清除浮动，在这个项目中体现出自己没有习惯用清除浮动，然后出现很多不应该有的问题<br><a href="https://www.zhihu.com/question/30938856" target="_blank" rel="noopener">overflow:hidden</a></p><p><a href="https://www.jqcool.net/jquery-swiper.html" target="_blank" rel="noopener">极其强大的移动端PC端滑块jquery插件Swiper</a></p><p><a href="http://caibaojian.com/toutiao/6215" target="_blank" rel="noopener">Web移动端布局的那些事儿</a></p><p><a href="https://www.ibm.com/developerworks/cn/web/1409_chengfu_css3flexbox/" target="_blank" rel="noopener">深入理解 CSS3 弹性盒布局模型</a></p><p>Base64其实是一种简单的置换加密方式，但是BASE64的用处往往并不是为了防止信息泄露，而且为了方便传输，进过BASE64编码后的信息会比原始信息长，大概是4/3倍。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects" target="_blank" rel="noopener">FormData 对象的使用</a></p><p> <a href="http://blog.csdn.net/honey_claire/article/details/7658490" target="_blank" rel="noopener">form表单的两种提交方式，submit和button的用法</a></p><p><a href="http://www.cnblogs.com/vanl/p/5857660.html" target="_blank" rel="noopener">Form表单提交</a></p><p><a href="http://www.jb51.net/article/65215.htm" target="_blank" rel="noopener">jquery中$each()方法的使用指南</a></p><p> <a href="http://blog.csdn.net/a4307515/article/details/50505167" target="_blank" rel="noopener">html5图片上传与预览实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在学校的时候，有幸接到一个关于思政类型的项目（类似于一些新闻网站）。其实内容并不复杂，只是当时能力有限，现在回头总结一下当时的一些问题。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>jQuery动画基础</title>
    <link href="http://yoursite.com/2018/01/07/jQuery%E5%8A%A8%E7%94%BB%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/07/jQuery动画基础/</id>
    <published>2018-01-07T12:05:08.000Z</published>
    <updated>2018-01-07T12:07:50.436Z</updated>
    
    <content type="html"><![CDATA[<p>1.隐藏元素的hide方法，<code>.hide(options)</code>，当提供hide方法的参数时，<code>.hide</code>成为一个动画方法，将匹配元素的高度，宽度，以及透明度，同时进行动画操作。有快捷参数<code>.hide(fast/slow)</code>,分别代表着200和600毫秒的延时！注意！jQuery在使用hide时，是会保持本身元素的原始属性值的，在之后通过对应的方法还原的时候还是初始值！css中类似的方法有<code>display：none</code></p><p>2.显示元素show方法<br><code>$(&#39;elem&#39;).hide(3000).show(3000)</code><br>让元素执行3秒的隐藏动画，然后执行3秒的显示动画。show和hide修改是display属性，通过是visibility属性布局需要通过Css方法单独设置</p><p>3.toggle方法：用于切换显示或隐藏匹配元素。没有参数<code>toggle()</code>，没有动画。提供参数，提供了时间，还有动画的回调。该方法其实就是hide和show的相互切换</p><p>4.下拉动画slideDown：常用操作<br><code>.slowDown([duration],[,complete])</code><br>具体使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;ele&quot;).slowDown(1000,function()&#123;</span><br><span class="line">        //等待动画执行一秒后，执行别的动作</span><br><span class="line">&#125;）;</span><br></pre></td></tr></table></figure><p>在使用该方法前，元素是先隐藏起来的，可以设置<code>display：none</code></p><p>5.上卷动画slideUp：最简单的使用就是不带参数<br><code>$(&quot;elem&quot;).slideUp();</code><br>含义：找到元素的高度，然后采用一个下滑动画让元素一直滑到隐藏，修改元素display样式属性为none，这样就可以确保这个元素不会影响页面布局了<br>带参数的用法<br><code>.slideUp([duration][,easing][,complete])</code><br>注意：因为动画是异步的，所以在动画执行之后执行某些操作就必须写到回调函数里面</p><p>6.上卷下拉切换slideToggle：当隐藏一个动画之后，可以设置display样式为none，以确保该元素不再影响页面布局</p><p>7.淡出动画fadeOut：用于隐藏所有匹配的元素，并带有淡出的过渡动画效果<br><code>.fadeOut([duration][,complete])</code><br>淡入动画fadeIn其用法和上面的类似<br>淡入淡出切换fadeToggle：如果当前元素是可见的吗，则将其隐藏（淡出）；如果元素当前是隐藏的，则将其显示（淡入）</p><p>8.淡入效果fadeTo：可以设置opacity的值，语法如下<br><code>.fadeTo(duration,opacity,[,complete])</code></p><p>9.animate方法：语法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.animate(properties[,duration][,easing][,complete])</span><br><span class="line">.animate(properties,options)</span><br></pre></td></tr></table></figure></p><p>该方法允许我们在任意数值的css属性上创建动画。参数分析：properties：一个或者多个css属性的键对所构成的object对象。要特别注意所有用于动画的属性必须是数字的，除非有特别说明。还有注意党委属性值的单位像素是PX。</p><p>10.停止动画<code>stop()</code><br>11.each()方法：jQuery的大部分方法都是针对元素合集的操作 ，所以jQuery会提供$(selector).each()来遍历jQuery对象<br>.each只是处理jQuery对象的方法，jQuery还提供了一个通用的jQuery.each()方法用来处理对象和数组的遍历，语法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(array,callback)</span><br><span class="line">jQuery.each(object,callback)</span><br></pre></td></tr></table></figure></p><p>第一个参数传递的就是一个对象或者数组，第二个是回调函数<br>each就是for循环方法的一个包装，内部就是通过for遍历数组与对象<br>jQuery.each()函数还会根据每次调用callback的返回值来决定后续动作，如果返回值为false，则停止循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.each([&quot;Aaron&quot;,&quot;慕课&quot;],function(index,value))&#123;</span><br><span class="line">    return false;//停止迭代</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>12.查找数组中的索引inArray：判断元素是否存在数组中，返回索引值，如果不存在該值，则返回-1。语法如下：<br><code>jQuery.inArray(value,array[,fromIndex])</code></p><p>13.去空格神器trim方法：用于去除字符串两端的空白字符，需要注意的是，如果这些空白符是在字符串的中间时，它们会被保留，不会被移除</p><p>14.jQuery是一个合集对象，如果需要单独操作合集中的某一个元素，可以通过.get()方法获取到，也可以获得某个。语法：<br><code>.get([index])</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.隐藏元素的hide方法，&lt;code&gt;.hide(options)&lt;/code&gt;，当提供hide方法的参数时，&lt;code&gt;.hide&lt;/code&gt;成为一个动画方法，将匹配元素的高度，宽度，以及透明度，同时进行动画操作。有快捷参数&lt;code&gt;.hide(fast/slow)
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>jQuery事件基础</title>
    <link href="http://yoursite.com/2018/01/07/jQuery%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/07/jQuery事件基础/</id>
    <published>2018-01-07T11:56:30.000Z</published>
    <updated>2018-01-07T12:03:11.852Z</updated>
    
    <content type="html"><![CDATA[<p>1.on()的多事件绑定 </p><p><code>.on(event[,selector][,data])</code></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-57a9e1ae17d22ff6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件绑定"></p><p>2.on的委托机制</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-85cd947fecbe515a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="on的委托机制"></p><p>3.通过.on()绑定的事件处理程序，通过off()方法移除该绑定</p><p>4.事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有在事件发生时才会产生，并且只能是事件处理函数内部访问，在所有的事件处理函数运行结束后，事件对象就被销毁</p><p>5.event.target可以是注册时候的属性，或者它的子元素。通常通过比较event.target和this来确定是不是由于冒泡出发的。经常用于事件冒泡时处理事件委托</p><p>6.简而言之，event.target代表当前触发事件的元素， 可以通过当前元素的一系列属性来判断是不是我们想要的元素</p><p>7.jQuery事件对象的属性和方法<br>event.type:获取事件的类型<br>event.pageX和event.pageY:获取鼠标当前相对于页面的坐标<br>event.preventDefault()方法：阻止默认行为<br>event.stopPropagation方法：阻止事件冒泡<br>event.which:获取鼠标单击时，单击的是鼠标的哪个键</p><p><strong>this和event.target的区别：</strong></p><p>js中事件是会冒泡的，所以this是可以变化的，但event.target不会变化，它永远是直接接受事件的目标DOM元素；</p><p><strong>.this和event.target都是dom对象</strong></p><p>如果要使用jquey中的方法可以将他们转换，为jquery对象：$(this)和$(event.target);比如：event.target和$(event.target)的使用</p><p>8.原生事件：浏览器提供的，需要有交互才能被触发</p><p>9.trigger:根据绑定到匹配元素的给定事件类型执行所有的处理程序和行为，支持自定义事件，并且定义时间还支持传递参数</p><p>10.mousemove(监听用户的操作)<br>用法：<code>$ele.mousemove()</code><br><code>$ele.mousemove(hander(eventObject))</code>每次触发点击操作都会回调执行函数hander()<br><code>$ele.mousemove([eventData],hander(eventObjet))</code>不同作用域下传递数据的问题</p><p>11.mouseover和mouseout事件，基本的用法和上面的mousemove一样</p><p>12.mouseenter和mouseleave可以让我们知道鼠标是否在元素内部或者元素外部。mouseover和mouseenter的区别，关键点：冒泡的方式处理问题。mouseenter只会在它绑定的元素上有效，而不会在后代结点上有效</p><p>13.hover可以传递两个回调函数，会很方便的使用<code>$(selector).hover(handerIn,handerOut)</code>第一个参数是鼠标移入时触发的 ，第二个参数是鼠标移出时触发的</p><p>14.focusin事件，捕获某一个元素或者其内部某一个元素获得焦点的时候的动作，而focusout是捕获失去焦点的动作，使用方法和第一点提到的类似</p><p>15.focus()在元素本身产生，focusin()在元素包含的元素中产生</p><p>16.change事件监听<code>&lt;input&gt;,&lt;textarea&gt;,&lt;select&gt;</code>的改变动作</p><p>17.当textarea或者文本类型的input元素的文本被选择时，会发生select事件（也只用于这两个了）</p><p>18.form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为<br>传统的方式是调用事件对象  e.preventDefault() 来处理， jQuery中可以直接在函数中最后结尾return false即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#target&quot;).submit(function(data) &#123; </span><br><span class="line">   return false; //阻止默认行为，提交表单</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>19.keydown和keyup(每次的内容都是之前输入的，当前的获取不到)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.on()的多事件绑定 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;.on(event[,selector][,data])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1784460-57a
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>jQuery选择器</title>
    <link href="http://yoursite.com/2018/01/07/jQuery%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    <id>http://yoursite.com/2018/01/07/jQuery选择器/</id>
    <published>2018-01-07T11:51:29.000Z</published>
    <updated>2018-01-07T12:04:03.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#test&quot;)</span><br><span class="line">$(&quot;.test&quot;)</span><br><span class="line">$(&quot;p&quot;)</span><br><span class="line">$(&quot;span,div,p.myclass&quot;)//选择所有div,&lt;span&gt;,和拥有class为myclass的p标签</span><br></pre></td></tr></table></figure><h3 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h3><p>通过dom元素之间的层次关系来获取特定元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div span&quot;)//选择div中的所有&lt;span&gt;元素+</span><br><span class="line">$(&quot;div&gt;span&quot;)//选取div下元素名是&lt;span&gt;的子元素</span><br><span class="line">$(&quot;.one+div&quot;)//选取class为one的下一个&lt;div&gt;同辈元素</span><br><span class="line">$(&quot;#two~div&quot;)//选取id为two的元素后面的所有&lt;div&gt;同辈元素</span><br><span class="line">//后面两个方法可以用其他方法代替如下</span><br><span class="line">$(&quot;.one&quot;).next(&quot;div&quot;);</span><br><span class="line">$(&quot;#pre&quot;).nextAll(&quot;div&quot;);</span><br></pre></td></tr></table></figure></p><h3 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h3><h4 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div:first&quot;)</span><br><span class="line">$(&quot;div:last&quot;)</span><br><span class="line">$(&quot;input:not(.myClass)&quot;)//选取input元素中不包含myClass类的元素</span><br><span class="line">$(&quot;input:even&quot;)//选取索引是偶数的input元素</span><br><span class="line">$(&quot;input：odd&quot;)</span><br><span class="line">$(&quot;input:eq(1)&quot;)//选取索引是1的input元素</span><br><span class="line">$(&quot;input：gt(1)&quot;)</span><br><span class="line">$(&quot;input:lt(1)&quot;)</span><br><span class="line">$(&quot;:header&quot;)//选取网页中所有的&lt;h1&gt;,&lt;h2&gt;,&lt;h3&gt;...</span><br><span class="line">$(&quot;div:animated&quot;)//选取正在执行动画的&lt;div&gt;元素</span><br><span class="line">$(&quot;:focus&quot;)//选取当前获得焦点的元素</span><br></pre></td></tr></table></figure><h4 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div:contains(&apos;我&apos;)&quot;)</span><br><span class="line">$(&quot;div:empty&quot;)//选取不包含子元素的&lt;div&gt;空元素</span><br><span class="line">$(&quot;div:has(p)&quot;)//选取含有&lt;p&gt;元素的div元素</span><br><span class="line">$(&quot;div:parent&quot;)//选取拥有子元素的div元素</span><br></pre></td></tr></table></figure><h3 id="可见性过滤选择器"><a href="#可见性过滤选择器" class="headerlink" title="可见性过滤选择器"></a>可见性过滤选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;:hidden&quot;)//选取所有不可见的元素。</span><br><span class="line">type=&quot;hidden&quot; display:none visibility:hidden等</span><br><span class="line">$(&quot;div:visible&quot;)//选择所有可见的div元素</span><br></pre></td></tr></table></figure><h4 id="属性过滤选择器"><a href="#属性过滤选择器" class="headerlink" title="属性过滤选择器"></a>属性过滤选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div[id]&quot;)</span><br><span class="line">$(&quot;div[title=test]&quot;)</span><br><span class="line">$(&quot;div[title!=test]&quot;)</span><br><span class="line">$(&quot;div[title^=test]&quot;)</span><br><span class="line">$(&quot;div[title$=test]&quot;)</span><br><span class="line">$(&quot;div[title*=test]&quot;)</span><br><span class="line">$(&apos;div[title|=&quot;en&quot;]&apos;)//选取title等于en或者以en为前缀（该字符后面紧跟一个连字符‘-’的元素）</span><br><span class="line">$(&apos;div[title~=&quot;uk&quot;]&apos;)//选取属性title用空格分隔的值中包含uk的元素</span><br><span class="line">$(&quot;div[id][title$=test]&quot;)//选择拥有属性id，并属性title以“test”结束的div元素</span><br></pre></td></tr></table></figure><h4 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:nth-child(index/even/odd/equation)</span><br><span class="line">:first-child</span><br><span class="line">:last-child</span><br><span class="line">:only-child</span><br></pre></td></tr></table></figure><h3 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;:input&quot;)//所有的input、textarea、select、button元素</span><br><span class="line">$(&quot;：text&quot;)</span><br><span class="line">$(&quot;:password&quot;)</span><br><span class="line">$(&quot;:radio&quot;)//单选框</span><br><span class="line">$(&quot;:checkbox&quot;)//选取所有的复选框</span><br><span class="line">$(&quot;:submit&quot;)//选择所有的提交按钮</span><br><span class="line">$(&quot;：image&quot;)//选择所有的图像按钮</span><br><span class="line">$(&quot;：reset&quot;)</span><br><span class="line">$(&quot;:button&quot;)</span><br><span class="line">$(&quot;:file&quot;)</span><br><span class="line">$(&quot;:hidden&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本选择器&quot;&gt;&lt;a href=&quot;#基本选择器&quot; class=&quot;headerlink&quot; title=&quot;基本选择器&quot;&gt;&lt;/a&gt;基本选择器&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://yoursite.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Python高级特性</title>
    <link href="http://yoursite.com/2018/01/07/Python%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/07/Python高级特性/</id>
    <published>2018-01-07T11:32:34.000Z</published>
    <updated>2018-01-07T11:44:11.957Z</updated>
    
    <content type="html"><![CDATA[<p>Python的代码不是越复杂越好，而是越简单越好，开发效率越简单越高</p><a id="more"></a><p><strong>切片</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;, &apos;Bob&apos;, &apos;Jack&apos;]</span><br><span class="line">[L[0], L[1], L[2]]</span><br></pre></td></tr></table></figure><p>另一种方法</p><p><code>L[0:3]</code></p><ul><li><p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p></li><li><p>如果第一个索引是0，还可以省略：</p></li></ul><p><code>L[:3]</code></p><ul><li>负数的情况</li></ul><p><code>L[-2:-1]</code></p><ul><li><p>tuple也是一种list，唯一区别是tuple不可变。因此，<br>tuple也可以用切片操作，只是操作的结果仍是tuple</p></li><li><p>字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串</p></li></ul><p>总结：有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。</p><p><strong>迭代</strong></p><p>在Python中，迭代是通过for … in来完成的</p><ul><li><p>Python的for循环抽象程度要高于Java的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上</p></li><li><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p></li><li><p>默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;</span><br><span class="line">for key in d:</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure><ul><li>由于字符串也是可迭代对象，因此，也可以作用于for循环</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for ch in &apos;ABC&apos;:</span><br><span class="line">    print(ch)</span><br></pre></td></tr></table></figure><ul><li>如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">isinstance(&apos;abc&apos;, Iterable) # str是否可迭代</span><br></pre></td></tr></table></figure><ul><li>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for i, value in enumerate([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]):</span><br><span class="line">      print(i, value)</span><br></pre></td></tr></table></figure><p><strong>列表生成式</strong></p><p><code>[x * x for x in range(1, 11)]</code></p><p><code>[x * x for x in range(1, 11) if x % 2 == 0]</code></p><p><code>[m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]</code></p><p>用两个for实现全排列</p><ul><li>for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;x&apos;: &apos;A&apos;, &apos;y&apos;: &apos;B&apos;, &apos;z&apos;: &apos;C&apos; &#125;</span><br><span class="line">for k, v in d.items():</span><br><span class="line">      print(k, &apos;=&apos;, v)</span><br></pre></td></tr></table></figure><p><strong>生成器</strong><br>受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了</p><p>一边循环一边计算的机制，称为生成器：generator</p><p>创建generator</p><ul><li>只要把一个列表生成式的[]改成()，就创建了一个generator</li></ul><p><code>g = (x * x for x in range(10))</code></p><ul><li>如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值</li></ul><p><code>next(g)</code></p><ul><li>使用for循环，因为generator也是可迭代对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x for x in range(10))</span><br><span class="line"> for n in g:</span><br><span class="line">    print(n)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure><ul><li>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + 1</span><br><span class="line">    return &apos;done&apos;</span><br></pre></td></tr></table></figure><ul><li>最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def odd():</span><br><span class="line">    print(&apos;step 1&apos;)</span><br><span class="line">    yield 1</span><br><span class="line">    print(&apos;step 2&apos;)</span><br><span class="line">    yield(3)</span><br><span class="line">    print(&apos;step 3&apos;)</span><br><span class="line">    yield(5)</span><br><span class="line"></span><br><span class="line">o = odd()</span><br><span class="line"> next(o)</span><br></pre></td></tr></table></figure><ul><li>同样的，把函数改成generator后，我们基本上从来不会用next()来获取下一个返回值，而是直接使用for循环来迭代</li></ul><p><strong>迭代器</strong></p><ul><li>可以直接作用于for循环的数据类型有以下几种：</li></ul><p>一类是集合数据类型，如list、tuple、dict、set、str等；</p><p>一类是generator，包括生成器和带yield的generator function。</p><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"> isinstance([], Iterable)</span><br></pre></td></tr></table></figure><ul><li>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</li></ul><p>可以使用isinstance()判断一个对象是否是Iterator对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line"> isinstance((x for x in range(10)), Iterator)</span><br><span class="line"> isinstance([], Iterator)</span><br></pre></td></tr></table></figure><ul><li>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</li></ul><p>把list、dict、str等Iterable变成Iterator可以使用iter()函数：</p><p><code>isinstance(iter([]), Iterator)</code></p><ul><li>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</li></ul><p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python的代码不是越复杂越好，而是越简单越好，开发效率越简单越高&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://yoursite.com/2018/01/07/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/07/Python基础/</id>
    <published>2018-01-07T11:24:20.000Z</published>
    <updated>2018-01-07T11:46:02.470Z</updated>
    
    <content type="html"><![CDATA[<p><strong>热门</strong><br><img src="http://upload-images.jianshu.io/upload_images/1784460-ba7c28e47612d36c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="  最近十年十种常用编程语言的变化图"></p><p><strong>特性</strong></p><ul><li>提供了非常完善的基础代码库</li><li>还有大量的第三方库</li><li>注释</li><li>对缩进严格要求</li><li>大小写敏感</li></ul><p>特点：简单优雅</p><a id="more"></a><p><a href="https://zhidao.baidu.com/question/1817640277692510988.html" target="_blank" rel="noopener">Python能够做什么</a></p><p><strong>输入输出：input，print</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(&apos;please enter your name: &apos;)</span><br><span class="line">print(&apos;hello,&apos;, name)</span><br></pre></td></tr></table></figure><p><strong>数据类型和 变量</strong></p><p>整数、浮点数、字符串、布尔值、空值  变量、常量</p><ul><li>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值</li></ul><p><strong>使用list和tuple</strong></p><ul><li>Python内置的一种数据类型列表：list,可以随时添加和删除其中的元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br><span class="line"> classmates</span><br><span class="line">[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]</span><br></pre></td></tr></table></figure><p>用len()函数可以获得list元素的个数</p><p><code>len(classmates)</code></p><ul><li>删除list末尾的元素，用pop()方法</li><li>list元素也可以是另一个的list（类似是二维数组）</li></ul><p>另一种有序列表叫做元组：tuple，tuple和list很类似，但是tuple一旦初始化后不能修改</p><p>不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。</p><p>可变？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;])</span><br><span class="line"> t[2][0] = &apos;X&apos;</span><br><span class="line">t[2][1] = &apos;Y&apos;</span><br><span class="line"> t</span><br><span class="line">(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;])</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1784460-c3679d103c934c74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="“变化”的tuple"></p><p><strong>条件判断</strong></p><p><strong>循环</strong></p><p><strong>使用dict和set</strong></p><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值存储，具有极快的查询速度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&apos;Michael&apos;: 95, &apos;Bob&apos;: 75, &apos;Tracy&apos;: 85&#125;</span><br><span class="line">d[&apos;Michael&apos;]</span><br><span class="line">95</span><br></pre></td></tr></table></figure><ul><li>可以通过in判断key是否存在</li><li>通过dict提供的get方法，如果key不存在，可以返回none，或者自己指定的value</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> d.get(&apos;Thomas&apos;)</span><br><span class="line"> d.get(&apos;Thomas&apos;, -1)</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><ul><li>删除key，用pop(key)方法</li><li>牢记dict的key必须是不可变对象</li></ul><p><strong>set</strong></p><p>set和dict类似，也是一组key的集合，但不存储value，在set中，没有重复的key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> s = set([1, 2, 3])</span><br><span class="line"> s</span><br><span class="line">&#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><ul><li>add(key)方法可以添加到set中</li><li>remove(key)可以删除元素</li><li>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</li></ul><p><strong>讨论不可变对象</strong></p><p>上面提到的list是可变对象，对list进行操作，list内部内容是会发生变化的。但是对于不可变对象，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> a = &apos;abc&apos;</span><br><span class="line"> b = a.replace(&apos;a&apos;, &apos;A&apos;)</span><br><span class="line"> b&apos;Abc</span><br><span class="line"> a</span><br><span class="line">&apos;abc&apos;</span><br></pre></td></tr></table></figure></p><p><strong>实例</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-e32367a05032c512.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原理"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-7540bef0ab9df851.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目标页面"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-b9cae5a60134e82f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="代码"></p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-073e3a7d25cf9799.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" "></p><p><strong>定义函数</strong></p><p>在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。</p><ul><li>空函数 pass 语句</li><li>参数检查</li><li>返回多个值</li><li>函数执行结束的时候没有return语句时，自动return None</li></ul><p><strong>函数参数</strong></p><p>默认参数</p><p>可变参数</p><p>*args是可变参数，args接收的是一个tuple<br>关键字参数</p><p>**kw是关键字参数，kw接收的是一个dict<br>参数组合</p><p>可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；<br>关键字参数既可以直接传入:func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{‘a’: 1, ‘b’: 2})</p><p>使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法</p><p>解决递归调用栈溢出的方法是通过<strong>尾递归</strong>优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;热门&lt;/strong&gt;&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1784460-ba7c28e47612d36c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;  最近十年十种常用编程语言的变化图&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供了非常完善的基础代码库&lt;/li&gt;
&lt;li&gt;还有大量的第三方库&lt;/li&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;li&gt;对缩进严格要求&lt;/li&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特点：简单优雅&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>FreeCodeCamp小结</title>
    <link href="http://yoursite.com/2018/01/07/FreeCodeCamp%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/07/FreeCodeCamp小结/</id>
    <published>2018-01-07T11:10:50.000Z</published>
    <updated>2018-01-07T12:48:49.206Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下在freeCodeCamp中做题过程学习的内容。</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>1.当设计表单的时候，你可以制定某些选项为必填项（required）,只有当用户填写了该选项后，用户才能提交表单</p><p><code>&lt;input type = &quot;text&quot; required&gt;</code></p><p>2.单选按钮的一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;</span><br><span class="line">  &lt;input type = &quot;radio&quot; name = &quot;indoor-outdoor&quot;&gt;indoor</span><br><span class="line">&lt;/label&gt;</span><br><span class="line">&lt;label&gt;</span><br><span class="line">  &lt;input type = &quot;radio&quot; name = &quot;indoor-outdoor&quot;&gt;outdoor</span><br><span class="line">&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>3.复选按钮（checkbox）,复选按钮是输入框的另一种类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;&lt;input type = &quot;checkbox&quot; name = &quot;personality&quot;&gt;1&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type = &quot;checkbox&quot; name =&quot;personality&quot;&gt;1&lt;/label&gt; </span><br><span class="line">&lt;label&gt;&lt;input type = &quot;checkbox&quot; name =&quot;personality&quot;&gt;1&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>4.使用checked属性，可以设置复选按钮和单选按钮被选中</p><p><code>&lt;input type = &quot;radio&quot; name = &quot;text-name&quot; checked&gt;</code></p><p>5.元素margin控制元素的border和元素实际占空间的距离。如果你将一个元素的margin设置成负值，元素将会变大</p><p>6.0 是 hex code（十六进制编码）中最小的一个，它代表颜色的完全缺失。<br>F 是 hex code（十六进制编码）中最大的一个，它代表最大可能的亮度。<br>color:#fff;白色的表示方法</p><p>7.Hex code 遵循 red-green-blue（红-绿-蓝），或者叫 rgb格式。hex code 中的前两位表示颜色中红色的数量，第三四位代表绿色的数量，第五六位代表蓝色的数量。</p><p>8.如果你做个算术，16 乘以 16 总共有 256 个值，所以从零开始计数的 rgb，和 hex code 一样有完全相同数量的可能数值。<br>让我们用黑色的 RGB 值 rgb(0, 0, 0) 替换掉 body 元素背景色的 hex code。 </p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><p>1.字符串中的转义序列<br>在需要转义的字符前面加上’\‘</p><p>\’ 单引号</p><p>\”双引号</p><p>\反斜杠符</p><p>\n 换行符</p><p>\r 回车符</p><p>\t 制表符</p><p>\b 退格符</p><p>\f 换页符</p><p>2.中括号操作符<br>中括号操作符的另一个使用方式是用变量来访问一个属性，当你需要遍历对象的属性列表或者查表时</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myDog = &quot;Hunter&quot;;</span><br><span class="line">var dogs = &#123;</span><br><span class="line">  Fido: &quot;Mutt&quot;,</span><br><span class="line">  Hunter: &quot;Doberman&quot;,</span><br><span class="line">  Snoopie: &quot;Beagle&quot;</span><br><span class="line">&#125;</span><br><span class="line">var breed = dogs[myDog];</span><br><span class="line">console.log(breed)// &quot;Doberman&quot;</span><br></pre></td></tr></table></figure><p>3.JSON<br>javascript object notation简称JSON，它使用javascript对象的格式来存储数据，json是灵活的，因为它允许数据结构是字符串，数字，布尔值，字符串和对象的任意值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总结一下在freeCodeCamp中做题过程学习的内容。&lt;/p&gt;
&lt;h2 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h2&gt;&lt;p&gt;1.当设计表单的时候，你可以制定某些选项为必填项（r
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库入门</title>
    <link href="http://yoursite.com/2018/01/07/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/01/07/mysql数据库入门/</id>
    <published>2018-01-07T09:30:31.000Z</published>
    <updated>2018-01-07T09:34:38.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关概念介绍"><a href="#相关概念介绍" class="headerlink" title="相关概念介绍"></a>相关概念介绍</h2><p>MySQL为关系型数据库（Relational Database Management System）,所谓的关系型可以理解为“表格”</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-6a67981b7a33aa6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="某班的学生信息中的相关概念"></p><ul><li>键（key）：表中用来识别某个特定人\物的方法，键的值在当前列中具有唯一性</li></ul><h2 id="windows下mysql的配置"><a href="#windows下mysql的配置" class="headerlink" title="windows下mysql的配置"></a>windows下mysql的配置</h2><h2 id="MySQL脚本的基本组成"><a href="#MySQL脚本的基本组成" class="headerlink" title="MySQL脚本的基本组成"></a>MySQL脚本的基本组成</h2><p>MySQL通过执行SQL脚本来完成对数据库的操作，该脚本由一条或者多条MySQL语句（SQL语句+扩展语句）组成，保存时脚本文件的后缀名为.sql</p><h2 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h2><p>三大数据类型：数字、日期\时间、字符串<br>数据类型</p><ul><li>整数：tinyint、smallint、mediumint、int、bigint</li><li>浮点型：float、 double、 real、 decimal<br>日期和时间：date、time、datetime、timestamp、year<br>字符串类型：</li><li>字符串: char、varchar</li><li>文本: tinytext、text、mediumtext、longtext</li><li>二进制(可用来存储图片、音乐等):tinyblob、blob、mediumblob、longblob</li></ul><h2 id="使MySQL数据库"><a href="#使MySQL数据库" class="headerlink" title="使MySQL数据库"></a>使MySQL数据库</h2><p><strong>登录</strong></p><p>mysql - h 主机名 -u 用户名 -p</p><p><code>mysql -u root -p</code></p><p><strong>创建一个数据库</strong></p><p><code>create database 数据库名 [其它选项];</code></p><p><strong>选择所要操作的数据库</strong></p><p>两种方法：</p><ul><li><p>在登录数据库时指定, 命令:<br>mysql -D 所选择的数据库名 -h 主机名 -u 用户名 -p<br>例如<br><code>mysql -D samp_db -u root -p</code></p></li><li><p>在登录后使用 use 语句指定, 命令:<br>use 数据库名;<br>use 语句可以不加分号, 执行 use samp_db 来选择刚刚创建的数据库, 选择成功后会提示: Database changed</p></li></ul><h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p>使用create table语句可完成对表格的创建<br><code>create table 表名称（列名称）;</code></p><h2 id="操作MySQL数据库"><a href="#操作MySQL数据库" class="headerlink" title="操作MySQL数据库"></a>操作MySQL数据库</h2><p><strong>向表中插入数据</strong></p><p>insert语句可以用来将一行或者多行数据插入到数据库表中，其中一般的形式如下：</p><p><code>insert [into] 表名[列名1，列名2，列名3...] value (值1，值2，值3,...)</code></p><p><strong>查询表中的数据</strong></p><p>select语句：</p><p><code>select 列名称 from 表名称 [查询条件]；</code></p><p><strong>按特定条件查询</strong></p><p>where关键词用于指定查询条件，用法形式：</p><p><code>select 列名称 from 表名称 where 条件;</code></p><p><strong>更新表中的数据</strong></p><p><code>update 表名称 set 列名称 = 新值 where 更新条件;</code></p><p><strong>删除表中的数据</strong></p><p>delete 语句：</p><p><code>delete from 表名称 where 删除条件;</code></p><h2 id="创建表后的修改"><a href="#创建表后的修改" class="headerlink" title="创建表后的修改"></a>创建表后的修改</h2><p><strong>添加列</strong></p><p>基本形式：</p><p><code>alter table 表名 add 列名 列数据类型 [after 插入位置];</code></p><p><strong>修改列</strong></p><p><code>alter table 表名 change 列名称 列新名称 新数据类型;</code></p><p><strong>删除列</strong></p><p><code>alter table 表名 drop 列名称;</code></p><p><strong>重命名表</strong></p><p><code>alter table 表名 rename 新表名;</code></p><p><strong>删除整张表</strong></p><p><code>drop table 表名;</code></p><p><strong>删除整个数据库</strong></p><p><code>drop database 数据库名;</code></p><p>emmmmm,未完待续</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关概念介绍&quot;&gt;&lt;a href=&quot;#相关概念介绍&quot; class=&quot;headerlink&quot; title=&quot;相关概念介绍&quot;&gt;&lt;/a&gt;相关概念介绍&lt;/h2&gt;&lt;p&gt;MySQL为关系型数据库（Relational Database Management System）,所谓
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>web前端和移动前端</title>
    <link href="http://yoursite.com/2018/01/07/%E5%89%8D%E7%AB%AF%E5%92%8C%E7%A7%BB%E5%8A%A8%E5%89%8D%E7%AB%AF/"/>
    <id>http://yoursite.com/2018/01/07/前端和移动前端/</id>
    <published>2018-01-07T09:14:45.000Z</published>
    <updated>2018-01-07T09:20:39.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>直接上一张图</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-5d5102b6f48d0df3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个的关系和区别"></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端是个很大的概念，我的理解是用户能够看到，直接接触到的层面都算是前端，比如IOS客户端界面，安卓客户端界面，网页界面，甚至PC/MAC 桌面端软件界面；现在最常见的说法一般是指Web前端，也就是针对于网页端开发的工作。</p><a id="more"></a><ul><li><p><strong>Web App：</strong>指的是【<a href="http://en.wikipedia.org/wiki/Web_application" target="_blank" rel="noopener">Web application</a>】，也就是以浏览器作为客户端的软件。</p></li><li><p><strong>Mobile Web App ：</strong>当然就是指在手机端打开的Web App啦。</p></li></ul><h2 id="移动客户端的开发类型"><a href="#移动客户端的开发类型" class="headerlink" title="移动客户端的开发类型"></a>移动客户端的开发类型</h2><ul><li><p><strong>Native App（原生APP）：</strong>也就是完全使用移动设备系统语言写的客户端，iPhone iPad就是纯Object-C，安卓就是纯JAVA, 就是用户看到的界面啦体验到的交互啦都是原生的。这是性能最棒的开发方式，但灵活性就没下面的好。</p></li><li><p><strong>Web App：</strong>这个就是在移动浏览器里打开的，纯HTML+CSS+JS，说白了就是个网页，只不过非常的富应用，比如手机浏览器访问的GMAIL啥啥的。但说白了就是在浏览器里打开的页面。。IOS支持可以在桌面创建访问的快捷方式，但是说到底还是打开Safari跑。。而且对设备硬件的接口什么的挺薄弱。</p></li><li><p><strong>Hybrid App：</strong>[<a href="http://en.wikipedia.org/wiki/HTML5_in_mobile_devices#Hybrid_Mobile_Apps" target="_blank" rel="noopener">HTML5 in mobile devices</a>] 我觉得这个更为合适一些。实际上是使用原生写了一个容器，然后使用HTML+CSS+JS来实现用户界面和交互。Web App的短处便可以克服（因为自己写的容器可以辅助暴露偏底层的接口，比如本地存储或者麦克风控制之类），同时比起纯原生的java或者object-c开发灵活性要高（更新可以更快更迅速，也不依赖于市场，因为说白了，就是自己下载更新网页资源。。）实际上这种方式已经不限于移动端。。豌豆荚其实是个pc端的hybrid app 哇~~~ 而且说实在的，桌面开发的性能就现在来说要比移动好很多。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;p&gt;直接上一张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1784460-5d5102b6f48d0df3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;两个的关系和区别&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h2&gt;&lt;p&gt;前端是个很大的概念，我的理解是用户能够看到，直接接触到的层面都算是前端，比如IOS客户端界面，安卓客户端界面，网页界面，甚至PC/MAC 桌面端软件界面；现在最常见的说法一般是指Web前端，也就是针对于网页端开发的工作。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>git 常用方法小结</title>
    <link href="http://yoursite.com/2018/01/06/git-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/06/git-常用方法小结/</id>
    <published>2018-01-06T15:18:37.000Z</published>
    <updated>2018-01-06T15:49:52.768Z</updated>
    
    <content type="html"><![CDATA[<p><strong>创建新仓库</strong></p><p>创建新的文件夹，打开，然后执行</p><p><code>git init</code></p><p>从而创建新的git仓库</p><p><strong>检出仓库</strong></p><p>执行下面的命令以创建一个本地仓库的克隆版本</p><p><code>git clone /path/to/repository</code></p><p>如果是远程服务器上的仓库，你的命令会是这样子</p><p><code>git clone username@host:/path/to/repository</code></p><p><strong>工作流</strong></p><p>本地仓库由git维护的三棵“树”组成。第一个是你的工作目录，它拥有实际文件；第二个是缓存区（index）,它像个缓存区域，临时保存你的改动；最后是HEAD，指向你最近一次提交后的结果</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-0a1979f35d37f158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工作流"></p><p><strong>添加和提交</strong></p><p>把它们添加到缓存区，使用下面的命令,右键该文件</p><p><code>git  add .</code></p><p>使用以下命令以实际提交改动：</p><p><code>git commit -m &quot;代码提交信息&quot;</code></p><p>现在，改动已经提交到HEAD，但是还没有到你的远程仓库</p><p><strong>推送改动</strong></p><p>你的改动现在已经在本地仓库的 <strong>HEAD</strong> 中了。执行如下命令以将这些改动提交到远端仓库</p><p><code>git push origin master</code><br>可以把 <em>master</em> 换成你想要推送的任何分支。 </p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><p><code>git remote add origin &lt;server&gt;</code><br>如此你就能够将你的改动推送到所添加的服务器上去了。</p><p><strong>分支</strong></p><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master是“默认的”。在其他分支上进行开发，完成后再将他们合并到主分支上</p><p><img src="http://upload-images.jianshu.io/upload_images/1784460-c167bec19c386efa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>创建一个叫做“feature_x”的分支，并切换过去：</p><p><code>git checkout -b feature_x</code></p><p>切换回主分支</p><p><code>git checkout master</code></p><p>再把新建的分支删除掉</p><p><code>git branch -d feature_x</code></p><p>除非你将分支推送到远程仓库，不然该分支就是不为他人所看到的</p><p><code>git push origin &lt;branch&gt;</code></p><p><strong>合并与更新</strong></p><p>要更新你的本地仓库至最新改动，执行：</p><p><code>git pull</code></p><p>以在你的工作目录中 <em>获取（fetch）</em> 并 <em>合并（merge）</em> 远端的改动。要合并其他分支到你的当前分支（例如 master），执行：</p><p><code>git merge &lt;branch&gt;</code></p><p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 <em>冲突（conflicts）</em>。 这时候就需要你修改这些文件来人肉合并这些 <em>冲突（conflicts）</em> 了。改完之后，你需要执行如下命令以将它们标记为合并成功：</p><p><code>git add &lt;filename&gt;</code></p><p>在合并改动之前，也可以使用如下命令查看：</p><p> <code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p><p><strong>标签</strong></p><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 <em>1.0.0</em> 的标签：</p><p><code>git tag 1.0.0 1b2e1d63ff</code></p><p><em>1b2e1d63ff</em> 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：</p><p><code>git log</code></p><p>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p><p><strong>替换本地改动</strong></p><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：</p><p><code>git checkout -- &lt;filename&gt;</code></p><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p><p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</p><p><code>git fetch origin</code><br><code>git reset --hard origin/master</code></p><p><strong>有用的贴士</strong></p><p>内建的图形化 git：</p><p><code>gitk</code></p><p>彩色的 git 输出：</p><p><code>git config color.ui true</code></p><p>显示历史记录时，只显示一行注释信息：</p><p><code>git config format.pretty oneline</code></p><p>交互地添加文件至缓存区：</p><p><code>git add -i</code></p><p><a href="http://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;创建新仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建新的文件夹，打开，然后执行&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从而创建新的git仓库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检出仓库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行下面的命令
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git常用方法" scheme="http://yoursite.com/tags/git%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
      <category term="git总结" scheme="http://yoursite.com/tags/git%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建属于自己的博客</title>
    <link href="http://yoursite.com/2018/01/06/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/01/06/使用hexo搭建属于自己的博客/</id>
    <published>2018-01-06T13:01:04.000Z</published>
    <updated>2018-01-06T15:50:07.938Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用hexo搭建博客</strong></p><p>很久就想搭建一个属于自己的博客了，之前能力不足（还有偷懒一直没有折腾），今天趁着周末放假，使用了Hexo与Github Pages搭建一个属于自己的个人博客，并成功部署。</p><p>决定明天将自己简书上面的文章迁移到自己的博客上来（不得不说是一个大工程）</p><p>参考资料：</p><p><a href="https://www.jianshu.com/p/0a234a805233" target="_blank" rel="noopener">Hexo+Github pages 创建一个属于自己的博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;使用hexo搭建博客&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很久就想搭建一个属于自己的博客了，之前能力不足（还有偷懒一直没有折腾），今天趁着周末放假，使用了Hexo与Github Pages搭建一个属于自己的个人博客，并成功部署。&lt;/p&gt;
&lt;p&gt;决定明天将自己简书
      
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo入门使用" scheme="http://yoursite.com/tags/Hexo%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
</feed>
